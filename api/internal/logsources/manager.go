// Package logsources manages dynamic Promtail log source configuration
package logsources

import (
	"fmt"
	"os"
	"os/exec"
	"sync"

	"gopkg.in/yaml.v3"
)

// LogSource represents a log source configuration
type LogSource struct {
	Name   string            `json:"name" yaml:"name"`
	Path   string            `json:"path" yaml:"path"`
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`
}

// sourcesFile is the YAML structure for storing sources
type sourcesFile struct {
	Sources []LogSource `yaml:"sources"`
}

// promtailScrapeConfig represents a Promtail scrape config
type promtailScrapeConfig struct {
	JobName       string              `yaml:"job_name"`
	StaticConfigs []promtailStatic    `yaml:"static_configs"`
	PipelineStages []map[string]any   `yaml:"pipeline_stages,omitempty"`
}

type promtailStatic struct {
	Targets []string          `yaml:"targets"`
	Labels  map[string]string `yaml:"labels"`
}

// promtailDynamicConfig is the structure for the dynamic config file
type promtailDynamicConfig struct {
	ScrapeConfigs []promtailScrapeConfig `yaml:"scrape_configs"`
}

// Manager handles log source configuration
type Manager struct {
	sourcesPath    string
	dynamicConfPath string
	mu             sync.RWMutex
	sources        []LogSource
}

// NewManager creates a new log sources manager
func NewManager(sourcesPath, dynamicConfPath string) (*Manager, error) {
	m := &Manager{
		sourcesPath:    sourcesPath,
		dynamicConfPath: dynamicConfPath,
		sources:        []LogSource{},
	}

	// Load existing sources
	if err := m.load(); err != nil {
		// If file doesn't exist, that's ok
		if !os.IsNotExist(err) {
			return nil, err
		}
	}

	return m, nil
}

// load reads sources from the YAML file
func (m *Manager) load() error {
	data, err := os.ReadFile(m.sourcesPath)
	if err != nil {
		return err
	}

	var sf sourcesFile
	if err := yaml.Unmarshal(data, &sf); err != nil {
		return err
	}

	m.sources = sf.Sources
	return nil
}

// save writes sources to the YAML file
func (m *Manager) save() error {
	sf := sourcesFile{Sources: m.sources}
	data, err := yaml.Marshal(&sf)
	if err != nil {
		return err
	}

	return os.WriteFile(m.sourcesPath, data, 0644)
}

// List returns all configured log sources
func (m *Manager) List() []LogSource {
	m.mu.RLock()
	defer m.mu.RUnlock()

	result := make([]LogSource, len(m.sources))
	copy(result, m.sources)
	return result
}

// Get returns a specific log source by name
func (m *Manager) Get(name string) (*LogSource, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, s := range m.sources {
		if s.Name == name {
			return &s, true
		}
	}
	return nil, false
}

// Add adds or updates a log source
func (m *Manager) Add(source LogSource) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Check if source with this name already exists
	found := false
	for i, s := range m.sources {
		if s.Name == source.Name {
			m.sources[i] = source
			found = true
			break
		}
	}

	if !found {
		m.sources = append(m.sources, source)
	}

	// Save and regenerate config
	if err := m.save(); err != nil {
		return err
	}

	return m.generatePromtailConfig()
}

// Delete removes a log source by name
func (m *Manager) Delete(name string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	newSources := make([]LogSource, 0, len(m.sources))
	found := false
	for _, s := range m.sources {
		if s.Name != name {
			newSources = append(newSources, s)
		} else {
			found = true
		}
	}

	if !found {
		return fmt.Errorf("source not found: %s", name)
	}

	m.sources = newSources

	// Save and regenerate config
	if err := m.save(); err != nil {
		return err
	}

	return m.generatePromtailConfig()
}

// generatePromtailConfig creates the dynamic Promtail config file
func (m *Manager) generatePromtailConfig() error {
	config := promtailDynamicConfig{
		ScrapeConfigs: make([]promtailScrapeConfig, 0, len(m.sources)),
	}

	for _, source := range m.sources {
		labels := make(map[string]string)
		labels["__path__"] = source.Path
		labels["source"] = source.Name
		
		// Add custom labels
		for k, v := range source.Labels {
			labels[k] = v
		}

		scrapeConfig := promtailScrapeConfig{
			JobName: fmt.Sprintf("custom_%s", source.Name),
			StaticConfigs: []promtailStatic{
				{
					Targets: []string{"localhost"},
					Labels:  labels,
				},
			},
		}

		config.ScrapeConfigs = append(config.ScrapeConfigs, scrapeConfig)
	}

	data, err := yaml.Marshal(&config)
	if err != nil {
		return err
	}

	// Write with header comment
	header := []byte("# Dynamic log sources - auto-generated by Forge API\n# Do not edit manually\n\n")
	content := append(header, data...)

	return os.WriteFile(m.dynamicConfPath, content, 0644)
}

// ReloadPromtail sends SIGHUP to Promtail to reload config
func (m *Manager) ReloadPromtail() error {
	cmd := exec.Command("docker", "exec", "forge-promtail", "kill", "-HUP", "1")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("promtail reload failed: %s - %w", string(output), err)
	}
	return nil
}

