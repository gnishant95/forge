// Package logsources manages dynamic Promtail log source configuration
package logsources

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sync"

	"gopkg.in/yaml.v3"
)

// LogSource represents a log source configuration
type LogSource struct {
	Name   string            `json:"name" yaml:"name"`
	Path   string            `json:"path" yaml:"path"`
	Labels map[string]string `json:"labels,omitempty" yaml:"labels,omitempty"`
}

// sourcesFile is the YAML structure for storing sources
type sourcesFile struct {
	Sources []LogSource `yaml:"sources"`
}

// promtailScrapeConfig represents a Promtail scrape config
type promtailScrapeConfig struct {
	JobName        string           `yaml:"job_name"`
	StaticConfigs  []promtailStatic `yaml:"static_configs"`
	PipelineStages []map[string]any `yaml:"pipeline_stages,omitempty"`
}

type promtailStatic struct {
	Targets []string          `yaml:"targets"`
	Labels  map[string]string `yaml:"labels"`
}

// promtailDynamicConfig is the structure for the dynamic config file
type promtailDynamicConfig struct {
	ScrapeConfigs []promtailScrapeConfig `yaml:"scrape_configs"`
}

// Manager handles log source configuration
type Manager struct {
	sourcesPath     string
	dynamicConfPath string
	mu              sync.RWMutex
	sources         []LogSource
}

// NewManager creates a new log sources manager
func NewManager(sourcesPath, dynamicConfPath string) (*Manager, error) {
	m := &Manager{
		sourcesPath:     sourcesPath,
		dynamicConfPath: dynamicConfPath,
		sources:         []LogSource{},
	}

	// Load existing sources
	if err := m.load(); err != nil {
		// If file doesn't exist, that's ok
		if !os.IsNotExist(err) {
			return nil, err
		}
	}

	return m, nil
}

// load reads sources from the YAML file
func (m *Manager) load() error {
	data, err := os.ReadFile(m.sourcesPath)
	if err != nil {
		return err
	}

	var sf sourcesFile
	if err := yaml.Unmarshal(data, &sf); err != nil {
		return err
	}

	m.sources = sf.Sources
	return nil
}

// save writes sources to the YAML file
func (m *Manager) save() error {
	sf := sourcesFile{Sources: m.sources}
	data, err := yaml.Marshal(&sf)
	if err != nil {
		return err
	}

	return os.WriteFile(m.sourcesPath, data, 0644)
}

// generateSourcesContent creates the sources file content without writing
func (m *Manager) generateSourcesContent() ([]byte, error) {
	sf := sourcesFile{Sources: m.sources}
	return yaml.Marshal(&sf)
}

// generatePromtailContent creates the Promtail config content without writing
func (m *Manager) generatePromtailContent() ([]byte, error) {
	config := promtailDynamicConfig{
		ScrapeConfigs: make([]promtailScrapeConfig, 0, len(m.sources)),
	}

	for _, source := range m.sources {
		labels := make(map[string]string)
		labels["__path__"] = source.Path
		labels["source"] = source.Name

		// Add custom labels
		for k, v := range source.Labels {
			labels[k] = v
		}

		scrapeConfig := promtailScrapeConfig{
			JobName: fmt.Sprintf("custom_%s", source.Name),
			StaticConfigs: []promtailStatic{
				{
					Targets: []string{"localhost"},
					Labels:  labels,
				},
			},
		}

		config.ScrapeConfigs = append(config.ScrapeConfigs, scrapeConfig)
	}

	data, err := yaml.Marshal(&config)
	if err != nil {
		return nil, err
	}

	// Prepend header comment
	header := []byte("# Dynamic log sources - auto-generated by Forge API\n# Do not edit manually\n\n")
	return append(header, data...), nil
}

// atomicPersist writes both sources and Promtail config atomically using temp files.
// If any step fails, temp files are cleaned up and the original files remain unchanged.
func (m *Manager) atomicPersist() error {
	// Generate both contents first (in-memory, no I/O side effects)
	sourcesContent, err := m.generateSourcesContent()
	if err != nil {
		return fmt.Errorf("failed to generate sources content: %w", err)
	}

	promtailContent, err := m.generatePromtailContent()
	if err != nil {
		return fmt.Errorf("failed to generate promtail content: %w", err)
	}

	// Create temp files in the same directories as targets (for atomic rename)
	sourcesDir := filepath.Dir(m.sourcesPath)
	promtailDir := filepath.Dir(m.dynamicConfPath)

	sourcesTmp, err := os.CreateTemp(sourcesDir, ".sources-*.tmp")
	if err != nil {
		return fmt.Errorf("failed to create temp sources file: %w", err)
	}
	sourcesTmpPath := sourcesTmp.Name()
	defer func() {
		sourcesTmp.Close()
		os.Remove(sourcesTmpPath) // Clean up if still exists (no-op after successful rename)
	}()

	promtailTmp, err := os.CreateTemp(promtailDir, ".promtail-*.tmp")
	if err != nil {
		return fmt.Errorf("failed to create temp promtail file: %w", err)
	}
	promtailTmpPath := promtailTmp.Name()
	defer func() {
		promtailTmp.Close()
		os.Remove(promtailTmpPath) // Clean up if still exists
	}()

	// Write to temp files
	if _, err := sourcesTmp.Write(sourcesContent); err != nil {
		return fmt.Errorf("failed to write temp sources file: %w", err)
	}
	if err := sourcesTmp.Chmod(0644); err != nil {
		return fmt.Errorf("failed to set temp sources file permissions: %w", err)
	}
	if err := sourcesTmp.Sync(); err != nil {
		return fmt.Errorf("failed to sync temp sources file: %w", err)
	}
	if err := sourcesTmp.Close(); err != nil {
		return fmt.Errorf("failed to close temp sources file: %w", err)
	}

	if _, err := promtailTmp.Write(promtailContent); err != nil {
		return fmt.Errorf("failed to write temp promtail file: %w", err)
	}
	if err := promtailTmp.Chmod(0644); err != nil {
		return fmt.Errorf("failed to set temp promtail file permissions: %w", err)
	}
	if err := promtailTmp.Sync(); err != nil {
		return fmt.Errorf("failed to sync temp promtail file: %w", err)
	}
	if err := promtailTmp.Close(); err != nil {
		return fmt.Errorf("failed to close temp promtail file: %w", err)
	}

	// Atomic renames - if either fails, we may have partial state,
	// but the defers will clean up temp files
	if err := os.Rename(sourcesTmpPath, m.sourcesPath); err != nil {
		return fmt.Errorf("failed to rename sources file: %w", err)
	}

	if err := os.Rename(promtailTmpPath, m.dynamicConfPath); err != nil {
		// Sources file was already renamed; attempt to restore by reloading from disk
		// This is a best-effort recovery - in practice this rename rarely fails
		// if the first one succeeded (same filesystem)
		return fmt.Errorf("failed to rename promtail config file: %w", err)
	}

	return nil
}

// List returns all configured log sources
func (m *Manager) List() []LogSource {
	m.mu.RLock()
	defer m.mu.RUnlock()

	result := make([]LogSource, len(m.sources))
	copy(result, m.sources)
	return result
}

// Get returns a specific log source by name
func (m *Manager) Get(name string) (*LogSource, bool) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	for _, s := range m.sources {
		if s.Name == name {
			return &s, true
		}
	}
	return nil, false
}

// Add adds or updates a log source
func (m *Manager) Add(source LogSource) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Save original state for rollback
	originalSources := make([]LogSource, len(m.sources))
	copy(originalSources, m.sources)

	// Check if source with this name already exists
	found := false
	for i, s := range m.sources {
		if s.Name == source.Name {
			m.sources[i] = source
			found = true
			break
		}
	}

	if !found {
		m.sources = append(m.sources, source)
	}

	// Atomically persist both sources and Promtail config
	if err := m.atomicPersist(); err != nil {
		// Rollback in-memory state on failure
		m.sources = originalSources
		return err
	}

	return nil
}

// Delete removes a log source by name
func (m *Manager) Delete(name string) error {
	m.mu.Lock()
	defer m.mu.Unlock()

	// Save original state for rollback
	originalSources := make([]LogSource, len(m.sources))
	copy(originalSources, m.sources)

	newSources := make([]LogSource, 0, len(m.sources))
	found := false
	for _, s := range m.sources {
		if s.Name != name {
			newSources = append(newSources, s)
		} else {
			found = true
		}
	}

	if !found {
		return fmt.Errorf("source not found: %s", name)
	}

	m.sources = newSources

	// Atomically persist both sources and Promtail config
	if err := m.atomicPersist(); err != nil {
		// Rollback in-memory state on failure
		m.sources = originalSources
		return err
	}

	return nil
}

// generatePromtailConfig creates the dynamic Promtail config file
func (m *Manager) generatePromtailConfig() error {
	config := promtailDynamicConfig{
		ScrapeConfigs: make([]promtailScrapeConfig, 0, len(m.sources)),
	}

	for _, source := range m.sources {
		labels := make(map[string]string)
		labels["__path__"] = source.Path
		labels["source"] = source.Name

		// Add custom labels
		for k, v := range source.Labels {
			labels[k] = v
		}

		scrapeConfig := promtailScrapeConfig{
			JobName: fmt.Sprintf("custom_%s", source.Name),
			StaticConfigs: []promtailStatic{
				{
					Targets: []string{"localhost"},
					Labels:  labels,
				},
			},
		}

		config.ScrapeConfigs = append(config.ScrapeConfigs, scrapeConfig)
	}

	data, err := yaml.Marshal(&config)
	if err != nil {
		return err
	}

	// Write with header comment
	header := []byte("# Dynamic log sources - auto-generated by Forge API\n# Do not edit manually\n\n")
	content := append(header, data...)

	return os.WriteFile(m.dynamicConfPath, content, 0644)
}

// ReloadPromtail sends SIGHUP to Promtail to reload config
func (m *Manager) ReloadPromtail() error {
	cmd := exec.Command("docker", "exec", "forge-promtail", "kill", "-HUP", "1")
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("promtail reload failed: %s - %w", string(output), err)
	}
	return nil
}
